<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>
<body style="margin:0;overflow:hidden;background:#000;cursor:grab">
<canvas id="c" style="touch-action: none; -webkit-tap-highlight-color: transparent;"></canvas>
<script>
/**
 * SHAPE: CUBE (iOS Fixed)
 * - Added iOS 13+ Permission Request to Click Listener.
 */

const CONFIG = {
  virtualSize: 4096,
colors: {
  satStroke: 95, satFill: 85, baseLight: 45, maxSheen: 40,
  alphaFrontFill: 0.15, alphaBackFill: 0.05,
  alphaFrontStroke: 0.8, alphaBackStroke: 0.4,

  // Palette taken from your SVG gradient:
  // #f00 -> #ff0 -> #0f0 -> #0ff -> #00f -> #f0f -> #f00
  hueStopPos: [0.00, 0.20, 0.2, 0.20, 0.85, 1.00],
  hueStops:   [  0,   60,  120,  180,  240,  300,  360],

  // Optional: set >1 to repeat the palette more times across faces
  // (shows more colors at once). Keep 1 for identical spread to now.
  cycles: 1
}
};

const canvas = c, ctx = canvas.getContext("2d", { alpha: false });

  var isAndroid = /Android/i.test(navigator.userAgent);
  var isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

// -- STATE --
let quads = []; 
let hueShift = 0, targetHue = 0;       
// Start at maxSheen so it loads "perfect" immediately
let sheen = 40, targetSheen = 40;          
let rotX = -0.5, rotY = 0.5; 
let targetRotX = -0.5, targetRotY = 0.5;
let renderScale = 1;
let autoRotSpeed = 0.002;
let isDragging = false, lastX = 0, lastY = 0, dragDistance = 0;
let inputType = 'mouse'; 
  const isAndroidUA = /Android/i.test(navigator.userAgent);
const isIOSUA = /iPhone|iPad|iPod/i.test(navigator.userAgent);

const BRIGHT_MIN_DESKTOP = 85;
const BRIGHT_MIN_MOBILE  = 95  // 90 - 5% (5 deg forward)
const BRIGHT_MAX_DESKTOP = 90;
const BRIGHT_MAX_MOBILE  = 80; // 90 + 10% (10 deg backward);

const BETA_FADE_MULT = 1.5;


// -- MATH --
const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const rndF = (min, max) => Math.random() * (max - min) + min;

const hueFromStops = (t) => {
  const pos = CONFIG.colors.hueStopPos;
  const hues = CONFIG.colors.hueStops;

  // clamp
  if (t <= pos[0]) return hues[0] % 360;
  if (t >= pos[pos.length - 1]) return hues[hues.length - 1] % 360;

  // find segment
  for (let i = 0; i < pos.length - 1; i++) {
    const a = pos[i], b = pos[i + 1];
    if (t >= a && t <= b) {
      const u = (t - a) / (b - a);
      const h = hues[i] + (hues[i + 1] - hues[i]) * u;
      return ((h % 360) + 360) % 360;
    }
  }
  return ((hues[0] % 360) + 360) % 360;
};


// -- RESIZE & SCALE --
function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = "100vw";
  canvas.style.height = "100vh";
  
  const width = canvas.width;
  const height = canvas.height;
  const minDim = Math.min(width, height);
  
  // Mobile Fit

const cssW = window.innerWidth;
const cssH = window.innerHeight;
const isPhone = Math.min(cssW, cssH) < 768 && (isAndroid || isIOS);

let zoomFactor = 1.0;

if (isAndroid) {
    // Specifically tuned for Android to prevent it from appearing too small
    zoomFactor = (cssW < cssH) ? 1 : 1; 
} else if (isIOS) {
    // Original scaling for iOS
    zoomFactor = (cssW < cssH) ? 1.02 : 1.10;
} else if (isPhone) {
    // Fallback for other mobile devices
    zoomFactor = 1.10;
}

  renderScale = minDim / (CONFIG.virtualSize * zoomFactor);
}
window.addEventListener('resize', resize);
resize();

function addQuad(v1, v2, v3, v4, n) { quads.push({ v: [v1, v2, v3, v4], n: n }); }

// -- SHAPE GENERATOR --
function buildCube() {
  const size = rnd(1024, 1024);
  const div = rnd(1, 20);
  const step = (size * 2) / div;
  for (let i = 0; i < div; i++) {
    for (let j = 0; j < div; j++) {
      const x = -size + i * step, y = -size + j * step;
      const n = x + step, m = y + step;
      addQuad({x:x, y:y, z:size}, {x:n, y:y, z:size}, {x:n, y:m, z:size}, {x:x, y:m, z:size}, {x:0,y:0,z:1});
      addQuad({x:n, y:y, z:-size}, {x:x, y:y, z:-size}, {x:x, y:m, z:-size}, {x:n, y:m, z:-size}, {x:0,y:0,z:-1});
      addQuad({x:size, y:y, z:n}, {x:size, y:y, z:x}, {x:size, y:m, z:x}, {x:size, y:m, z:n}, {x:1,y:0,z:0});
      addQuad({x:-size, y:y, z:x}, {x:-size, y:y, z:n}, {x:-size, y:m, z:n}, {x:-size, y:m, z:x}, {x:-1,y:0,z:0});
      addQuad({x:x, y:size, z:n}, {x:n, y:size, z:n}, {x:n, y:size, z:x}, {x:x, y:size, z:x}, {x:0,y:1,z:0});
      addQuad({x:x, y:-size, z:x}, {x:n, y:-size, z:x}, {x:n, y:-size, z:n}, {x:x, y:-size, z:n}, {x:0,y:-1,z:0});
    }
  }
}

function init() {
  quads = [];
  buildCube();
  autoRotSpeed = (Math.random() > 0.5 ? 1 : -1) * rndF(0.001, 0.004);
  const noiseType = rnd(0, 2);
  const amp = rnd(10, 90);
  quads.forEach(q => {
    q.v = q.v.map(v => {
      let dx=0, dy=0, dz=0;
      if (noiseType === 0) { dx = Math.sin(v.y * 0.005) * amp; } 
      else if (noiseType === 1) { dx = (Math.random()-0.5) * amp; dy = (Math.random()-0.5) * amp; dz = (Math.random()-0.5) * amp; } 
      else { 
         const ang = v.y * 0.001 * (amp/30);
         const nx = v.x * Math.cos(ang) - v.z * Math.sin(ang);
         const nz = v.x * Math.sin(ang) + v.z * Math.cos(ang);
         return {x:nx, y:v.y, z:nz};
      }
      return {x: v.x+dx, y: v.y+dy, z: v.z+dz};
    });
  });
}

function project(p, rx, ry) {
  const x1 = p.x * Math.cos(ry) - p.z * Math.sin(ry);
  const z1 = p.x * Math.sin(ry) + p.z * Math.cos(ry);
  const y2 = p.y * Math.cos(rx) - z1 * Math.sin(rx);
  const z2 = p.y * Math.sin(rx) + z1 * Math.cos(rx);
  const fov = 3500;
  const scale = fov / (fov - z2);
  return { x: 2048 + x1 * scale, y: 2048 + y2 * scale, z: z2 };
}

function draw() {
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (inputType === 'tilt') {
      hueShift = targetHue; 
      sheen = targetSheen;
  } else {
      hueShift += (targetHue - hueShift) * 0.05;
      sheen += (targetSheen - sheen) * 0.05;
  }

  if (!isDragging) { targetRotY += autoRotSpeed; }
  rotX += (targetRotX - rotX) * 0.1;
  rotY += (targetRotY - rotY) * 0.1;

  const renderList = quads.map(q => {
    const p = q.v.map(v => project(v, rotX, rotY));
    const zDepth = (p[0].z + p[1].z + p[2].z + p[3].z) / 4;
    const ux = p[1].x - p[0].x, uy = p[1].y - p[0].y;
    const vx = p[3].x - p[0].x, vy = p[3].y - p[0].y;
    const isFront = (ux * vy - uy * vx) > 0;
    return { p, z: zDepth, isFront };
  });

  renderList.sort((a, b) => a.z - b.z);
  const total = renderList.length;

  ctx.save();
  const offsetX = (canvas.width - CONFIG.virtualSize * renderScale) / 2;
  const offsetY = (canvas.height - CONFIG.virtualSize * renderScale) / 2;
  ctx.translate(offsetX, offsetY);
  ctx.scale(renderScale, renderScale);

  for (let i = 0; i < total; i++) {
    const q = renderList[i];
    if (q.z > 2500) continue;

    const t = (((hueShift / 360) + (i / total) * CONFIG.colors.cycles) % 1 + 1) % 1;
    const hue = hueFromStops(t);

    const sheenEffect = Math.min(CONFIG.colors.maxSheen, sheen); 
    const light = CONFIG.colors.baseLight + sheenEffect; 
    
    const alphaFill = q.isFront ? CONFIG.colors.alphaFrontFill : CONFIG.colors.alphaBackFill; 
    const alphaStroke = q.isFront ? CONFIG.colors.alphaFrontStroke : CONFIG.colors.alphaBackStroke;
    
    ctx.strokeStyle = `hsla(${hue}, ${CONFIG.colors.satStroke}%, ${light + 10}%, ${alphaStroke})`;
    //ctx.lineWidth = 2 / renderScale;
          if (isAndroid) {
          ctx.lineWidth = 2 / renderScale;
      } else if (isIOS) {
          ctx.lineWidth = 2 / renderScale;

      } else {
          ctx.lineWidth = 2 / renderScale;
      }
    ctx.fillStyle = `hsla(${hue}, ${CONFIG.colors.satFill}%, ${light}%, ${alphaFill})`;

    ctx.beginPath();
    ctx.moveTo(q.p[0].x, q.p[0].y);
    ctx.lineTo(q.p[1].x, q.p[1].y);
    ctx.lineTo(q.p[2].x, q.p[2].y);
    ctx.lineTo(q.p[3].x, q.p[3].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();
  requestAnimationFrame(draw);
}

// -- INPUTS --
window.addEventListener('deviceorientation', e => {
  if (e.gamma === null) return;
  inputType = 'tilt'; 
  targetHue = (e.gamma * 4 + 360) % 360; 
  const betaAbs = Math.abs(e.beta); // upright is ~90 regardless of sign
  
  const isMobile = isAndroidUA || isIOSUA;
  const min = isMobile ? BRIGHT_MIN_MOBILE : BRIGHT_MIN_DESKTOP;
  const max = isMobile ? BRIGHT_MAX_MOBILE : BRIGHT_MAX_DESKTOP;

  // distance outside the "full bright" band
  let dist = 0;
  if (betaAbs < min) dist = min - betaAbs;
  else if (betaAbs > max) dist = betaAbs - max;

  // full bright inside band, fade out as you leave it
  targetSheen = Math.max(0, CONFIG.colors.maxSheen - dist * BETA_FADE_MULT); 
});

window.addEventListener('mousemove', e => {
    if(!isDragging) {
        inputType = 'mouse'; 
        targetHue = (e.clientX / window.innerWidth) * 360;
        targetSheen = (e.clientY / window.innerHeight) * 50;
    }
});

const startDrag = (x, y) => { isDragging = true; lastX = x; lastY = y; dragDistance = 0; document.body.style.cursor = "grabbing"; };
const moveDrag = (x, y) => { 
  if (!isDragging) return; 
  const dx = x - lastX;
  const dy = y - lastY;
  dragDistance += Math.abs(dx) + Math.abs(dy);
  targetRotY += dx * 0.005; 
  targetRotX += dy * 0.005; 
  lastX = x; 
  lastY = y; 
};
// Landmark: Variables
let lastTap = 0;
let clickTimer = null;

const endDrag = (e) => {
    isDragging = false;
    document.body.style.cursor = "grab";

    // 1. Only trigger if the user didn't actually drag (keep your dragDistance logic)
    if (dragDistance < 10) {
        const now = Date.now();
        const TIMESPAN = 300; // ms window for double tap

        if (now - lastTap < TIMESPAN) {
            // --- DOUBLE TAP / DOUBLE CLICK DETECTED ---
            clearTimeout(clickTimer); // Stop the single click (init) from firing
            
            const link = document.createElement('a');
            link.download = 'cube.png';
            link.href = canvas.toDataURL();
            link.click();
            
            lastTap = 0; // Reset to prevent triple-tap bugs
        } else {
            // --- POTENTIAL SINGLE CLICK ---
            lastTap = now;
            
            // Clear any existing timer
            if (clickTimer) clearTimeout(clickTimer);

            // Set a delay to see if a second tap comes in
            clickTimer = setTimeout(() => {
                // TARGET: iOS Permission + init()
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                    .then(response => { if (response === 'granted') { init(); } })
                    .catch(console.error);
                } else {
                    init(); // Desktop/Android
                }
            }, 250); 
        }
    }
};

// --- Listeners: REMOVE your old 'click' and 'dblclick' listeners ---
canvas.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
window.addEventListener('mouseup', e => endDrag(e));

canvas.addEventListener('touchstart', e => {
    startDrag(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

window.addEventListener('touchmove', e => {
    e.preventDefault(); // Critical for Android zoom/scroll prevention
    moveDrag(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

window.addEventListener('touchend', e => {
    // Prevent the "ghost click" on Android which causes multiple saves
    if (e.cancelable) e.preventDefault(); 
    endDrag(e);
});


init();
draw();
</script>
</body>
</html>
