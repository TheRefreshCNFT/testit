<!DOCTYPE html>
<html>
<body style="margin:0;overflow:hidden;background:#000;cursor:grab">
<canvas id="c"></canvas>
<script>
/**
 * SHAPE: CUBE (iOS Fixed)
 * - Added iOS 13+ Permission Request to Click Listener.
 */

const CONFIG = {
  virtualSize: 4096,
  colors: {
    satStroke: 95, satFill: 85, baseLight: 45, maxSheen: 40,
    alphaFrontFill: 0.15, alphaBackFill: 0.05,
    alphaFrontStroke: 0.8, alphaBackStroke: 0.4
  }
};

const canvas = c, ctx = canvas.getContext("2d", { alpha: false });

// -- STATE --
let quads = []; 
let hueShift = 0, targetHue = 0;       
let sheen = 0, targetSheen = 0;          
let rotX = -0.5, rotY = 0.5; 
let targetRotX = -0.5, targetRotY = 0.5;
let renderScale = 1;
let autoRotSpeed = 0.002;
let isDragging = false, lastX = 0, lastY = 0, dragDistance = 0;
let inputType = 'mouse';
let hoverIdleTimer = null;
let tiltBaseGamma = null;
let tiltBaseBeta = null;
let tiltBaseHue = 0;
let tiltBaseSheen = 0;
const isAndroidUA = /Android/i.test(navigator.userAgent);
const isIOSUA = /iPhone|iPad|iPod/i.test(navigator.userAgent);

// Brightest band around 90°
// All devices: 85–95
// Mobile: extend lower bound down to 75
const BRIGHT_MIN_DESKTOP = 175;
const BRIGHT_MIN_MOBILE  = 165;
const BRIGHT_MAX         = 5;

// How fast it fades when outside the band
const BETA_FADE_MULT = 1.5;



// -- MATH --
const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const rndF = (min, max) => Math.random() * (max - min) + min;

// -- RESIZE & SCALE --
function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = "100vw";
  canvas.style.height = "100vh";
  
  const width = canvas.width;
  const height = canvas.height;
  const minDim = Math.min(width, height);
  
  // Mobile Fit
  var isAndroid = /Android/i.test(navigator.userAgent);
  var isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

  const cssW = window.innerWidth;
  const cssH = window.innerHeight;
  const isPhone = Math.min(cssW, cssH) < 768 && (isAndroid || isIOS);

  // zoomFactor > 1 => slightly smaller render => prevents corner clipping during rotation
  let zoomFactor = 1.0;
  if (isPhone) zoomFactor = (cssW < cssH) ? 1.12 : 1.20;

  renderScale = minDim / (CONFIG.virtualSize * zoomFactor);
}
window.addEventListener('resize', resize);
resize();

function addQuad(v1, v2, v3, v4, n) { quads.push({ v: [v1, v2, v3, v4], n: n }); }

// -- SHAPE GENERATOR --
function buildCube() {
  const size = rnd(1024, 1024);
  const div = rnd(2, 10);
  const step = (size * 2) / div;
  for (let i = 0; i < div; i++) {
    for (let j = 0; j < div; j++) {
      const x = -size + i * step, y = -size + j * step;
      const n = x + step, m = y + step;
      addQuad({x:x, y:y, z:size}, {x:n, y:y, z:size}, {x:n, y:m, z:size}, {x:x, y:m, z:size}, {x:0,y:0,z:1});
      addQuad({x:n, y:y, z:-size}, {x:x, y:y, z:-size}, {x:x, y:m, z:-size}, {x:n, y:m, z:-size}, {x:0,y:0,z:-1});
      addQuad({x:size, y:y, z:n}, {x:size, y:y, z:x}, {x:size, y:m, z:x}, {x:size, y:m, z:n}, {x:1,y:0,z:0});
      addQuad({x:-size, y:y, z:x}, {x:-size, y:y, z:n}, {x:-size, y:m, z:n}, {x:-size, y:m, z:x}, {x:-1,y:0,z:0});
      addQuad({x:x, y:size, z:n}, {x:n, y:size, z:n}, {x:n, y:size, z:x}, {x:x, y:size, z:x}, {x:0,y:1,z:0});
      addQuad({x:x, y:-size, z:x}, {x:n, y:-size, z:x}, {x:n, y:-size, z:n}, {x:x, y:-size, z:n}, {x:0,y:-1,z:0});
    }
  }
}

function init() {
  quads = [];
  buildCube();
  autoRotSpeed = (Math.random() > 0.5 ? 1 : -1) * rndF(0.001, 0.004);
  targetHue = rndF(0, 360);
  targetSheen = CONFIG.colors.maxSheen;
  hueShift = targetHue;
  sheen = targetSheen;
  tiltBaseGamma = null;
  tiltBaseBeta = null;
  tiltBaseHue = targetHue;
  tiltBaseSheen = targetSheen;
  const noiseType = rnd(0, 2);
  const amp = rnd(10, 90);
  quads.forEach(q => {
    q.v = q.v.map(v => {
      let dx=0, dy=0, dz=0;
      if (noiseType === 0) { dx = Math.sin(v.y * 0.005) * amp; } 
      else if (noiseType === 1) { dx = (Math.random()-0.5) * amp; dy = (Math.random()-0.5) * amp; dz = (Math.random()-0.5) * amp; } 
      else { 
         const ang = v.y * 0.001 * (amp/30);
         const nx = v.x * Math.cos(ang) - v.z * Math.sin(ang);
         const nz = v.x * Math.sin(ang) + v.z * Math.cos(ang);
         return {x:nx, y:v.y, z:nz};
      }
      return {x: v.x+dx, y: v.y+dy, z: v.z+dz};
    });
  });
}

function project(p, rx, ry) {
  const x1 = p.x * Math.cos(ry) - p.z * Math.sin(ry);
  const z1 = p.x * Math.sin(ry) + p.z * Math.cos(ry);
  const y2 = p.y * Math.cos(rx) - z1 * Math.sin(rx);
  const z2 = p.y * Math.sin(rx) + z1 * Math.cos(rx);
  const fov = 3500;
  const scale = fov / (fov - z2);
  return { x: 2048 + x1 * scale, y: 2048 + y2 * scale, z: z2 };
}

function draw() {
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (inputType === 'tilt') {
      hueShift = targetHue; 
      sheen = targetSheen;
  } else {
      hueShift += (targetHue - hueShift) * 0.05;
      sheen += (targetSheen - sheen) * 0.05;
  }

  if (!isDragging) { targetRotY += autoRotSpeed; }
  rotX += (targetRotX - rotX) * 0.1;
  rotY += (targetRotY - rotY) * 0.1;

  const renderList = quads.map(q => {
    const p = q.v.map(v => project(v, rotX, rotY));
    const zDepth = (p[0].z + p[1].z + p[2].z + p[3].z) / 4;
    const ux = p[1].x - p[0].x, uy = p[1].y - p[0].y;
    const vx = p[3].x - p[0].x, vy = p[3].y - p[0].y;
    const isFront = (ux * vy - uy * vx) > 0;
    return { p, z: zDepth, isFront };
  });

  renderList.sort((a, b) => a.z - b.z);
  const total = renderList.length;

  ctx.save();
  const offsetX = (canvas.width - CONFIG.virtualSize * renderScale) / 2;
  const offsetY = (canvas.height - CONFIG.virtualSize * renderScale) / 2;
  ctx.translate(offsetX, offsetY);
  ctx.scale(renderScale, renderScale);

  for (let i = 0; i < total; i++) {
    const q = renderList[i];
    if (q.z > 2500) continue;

    const hue = (hueShift + (i / total) * 360) % 360;
    const sheenEffect = Math.min(CONFIG.colors.maxSheen, sheen); 
    const light = CONFIG.colors.baseLight + sheenEffect; 
    
    const alphaFill = q.isFront ? CONFIG.colors.alphaFrontFill : CONFIG.colors.alphaBackFill; 
    const alphaStroke = q.isFront ? CONFIG.colors.alphaFrontStroke : CONFIG.colors.alphaBackStroke;
    
    ctx.strokeStyle = `hsla(${hue}, ${CONFIG.colors.satStroke}%, ${light + 10}%, ${alphaStroke})`;
    ctx.lineWidth = 2 / renderScale; 
    ctx.fillStyle = `hsla(${hue}, ${CONFIG.colors.satFill}%, ${light}%, ${alphaFill})`;

    ctx.beginPath();
    ctx.moveTo(q.p[0].x, q.p[0].y);
    ctx.lineTo(q.p[1].x, q.p[1].y);
    ctx.lineTo(q.p[2].x, q.p[2].y);
    ctx.lineTo(q.p[3].x, q.p[3].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();
  requestAnimationFrame(draw);
}

// -- INPUTS --
window.addEventListener('deviceorientation', e => {
  if (e.gamma === null) return;
  inputType = 'tilt'; 
  // Hue stays driven by gamma (keeps your existing tilt color behavior)
  targetHue = (e.gamma * 4 + 360) % 360;

  // Brightness (sheen) is driven by beta around the fixed 90° band
  const betaAbs = Math.abs(e.beta);
  const brightMin = (isAndroidUA || isIOSUA) ? BRIGHT_MIN_MOBILE : BRIGHT_MIN_DESKTOP;

  // Distance outside the "full color" band
  let dist = 0;
  if (betaAbs < brightMin) dist = brightMin - betaAbs;
  else if (betaAbs > BRIGHT_MAX) dist = betaAbs - BRIGHT_MAX;

  // Full color inside band, fade out as you move away, fade back in as you return
  targetSheen = Math.max(0, tiltBaseSheen - dist * BETA_FADE_MULT);
});

window.addEventListener('mousemove', e => {
    if(!isDragging) {
        inputType = 'mouse'; 
        targetHue = (e.clientX / window.innerWidth) * 360;
        const nx = (e.clientX / window.innerWidth) - 0.5;
        const ny = (e.clientY / window.innerHeight) - 0.5;
        const dist = Math.min(1, Math.sqrt(nx*nx + ny*ny) * 2); // 0 center -> 1 edges
        const BRIGHT = CONFIG.colors.maxSheen;
        const PALE = CONFIG.colors.maxSheen * 0.55;
        targetSheen = PALE + dist * (BRIGHT - PALE);

    }
});

const startDrag = (x, y) => { isDragging = true; lastX = x; lastY = y; dragDistance = 0; document.body.style.cursor = "grabbing"; };
const moveDrag = (x, y) => { 
  if (!isDragging) return; 
  const dx = x - lastX;
  const dy = y - lastY;
  dragDistance += Math.abs(dx) + Math.abs(dy);
  targetRotY += dx * 0.005; 
  targetRotX += dy * 0.005; 
  lastX = x; 
  lastY = y; 
};
const endDrag = () => { isDragging = false; document.body.style.cursor = "grab"; };

canvas.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
window.addEventListener('mouseup', endDrag);
canvas.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
window.addEventListener('touchmove', e => { e.preventDefault(); moveDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
window.addEventListener('touchend', endDrag);

// CLICK LISTENER WITH iOS PERMISSION REQUEST
canvas.addEventListener('click', (e) => {
  if (dragDistance < 10) {
    // TARGET: iOS 13+ Devices
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
             // iOS will now fire the deviceorientation event
          }
        })
        .catch(console.error);
    }
    init();
  }
});

init();
draw();
</script>
</body>
</html>
