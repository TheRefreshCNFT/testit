<!DOCTYPE html>
<html>
<body style="margin:0;overflow:hidden;background:#000;cursor:grab">
<canvas id="c"></canvas>
<script>
/**
 * SHAPE: SPIRAL (Desktop Optimized + Smart Input)
 */

const CONFIG = {
  virtualSize: 4096,
  colors: {
    satStroke: 95, satFill: 85, baseLight: 45, maxSheen: 40,
    alphaFrontFill: 0.15, alphaBackFill: 0.05,
    alphaFrontStroke: 0.8, alphaBackStroke: 0.4
  }
};

const canvas = c, ctx = canvas.getContext("2d", { alpha: false });
let quads = [], hueShift = 0, targetHue = 0, sheen = 0, targetSheen = 0;
let rotX = -0.5, rotY = 0.5, targetRotX = -0.5, targetRotY = 0.5;
let renderScale = 1, autoRotSpeed = 0.002;
let isDragging = false, lastX = 0, lastY = 0, dragDistance = 0;

const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const rndF = (min, max) => Math.random() * (max - min) + min;

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = "100vw";
  canvas.style.height = "100vh";
  const minDim = Math.min(canvas.width, canvas.height);
  renderScale = minDim / CONFIG.virtualSize; 
}
window.addEventListener('resize', resize);
resize();

function addQuad(v1, v2, v3, v4, n) { quads.push({ v: [v1, v2, v3, v4], n: n }); }

function buildSpiral() {
  const height = 2200, radius = rnd(400, 800), twists = rnd(2, 5), stacks = rnd(20, 60), sides = rnd(3, 6);
  for (let i = 0; i < stacks; i++) {
    const y1 = -height/2 + (i/stacks)*height, y2 = -height/2 + ((i+1)/stacks)*height;
    const rot1 = (i/stacks)*Math.PI*2*twists, rot2 = ((i+1)/stacks)*Math.PI*2*twists;
    for (let j = 0; j < sides; j++) {
      const ang1 = (j/sides)*Math.PI*2, ang2 = ((j+1)/sides)*Math.PI*2;
      const p = (y, rOffset, ang) => ({ x: radius*Math.cos(ang+rOffset), y: y, z: radius*Math.sin(ang+rOffset) });
      addQuad(p(y1, rot1, ang1), p(y1, rot1, ang2), p(y2, rot2, ang2), p(y2, rot2, ang1), {x:1, y:0, z:0});
    }
  }
}

function init() {
  quads = [];
  buildSpiral();
  autoRotSpeed = (Math.random() > 0.5 ? 1 : -1) * rndF(0.001, 0.004);
  const noiseType = rnd(0, 2);
  const amp = rnd(10, 90);
  quads.forEach(q => {
    q.v = q.v.map(v => {
      let dx=0, dy=0, dz=0;
      if (noiseType === 0) { dx = Math.sin(v.y * 0.005) * amp; } 
      else if (noiseType === 1) { dx = (Math.random()-0.5) * amp; dy = (Math.random()-0.5) * amp; dz = (Math.random()-0.5) * amp; } 
      else { 
         const ang = v.y * 0.001 * (amp/30);
         const nx = v.x * Math.cos(ang) - v.z * Math.sin(ang);
         const nz = v.x * Math.sin(ang) + v.z * Math.cos(ang);
         return {x:nx, y:v.y, z:nz};
      }
      return {x: v.x+dx, y: v.y+dy, z: v.z+dz};
    });
  });
}

function project(p, rx, ry) {
  const x1 = p.x * Math.cos(ry) - p.z * Math.sin(ry);
  const z1 = p.x * Math.sin(ry) + p.z * Math.cos(ry);
  const y2 = p.y * Math.cos(rx) - z1 * Math.sin(rx);
  const z2 = p.y * Math.sin(rx) + z1 * Math.cos(rx);
  const fov = 3500;
  const scale = fov / (fov - z2);
  return { x: 2048 + x1 * scale, y: 2048 + y2 * scale, z: z2 };
}

function draw() {
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  hueShift += (targetHue - hueShift) * 0.05;
  sheen += (targetSheen - sheen) * 0.05;

  if (!isDragging) { targetRotY += autoRotSpeed; }
  rotX += (targetRotX - rotX) * 0.1;
  rotY += (targetRotY - rotY) * 0.1;

  const renderList = quads.map(q => {
    const p = q.v.map(v => project(v, rotX, rotY));
    const zDepth = (p[0].z + p[1].z + p[2].z + p[3].z) / 4;
    const ux = p[1].x - p[0].x, uy = p[1].y - p[0].y;
    const vx = p[3].x - p[0].x, vy = p[3].y - p[0].y;
    const isFront = (ux * vy - uy * vx) > 0;
    return { p, z: zDepth, isFront };
  });

  renderList.sort((a, b) => a.z - b.z);
  const total = renderList.length;

  ctx.save();
  const offsetX = (canvas.width - CONFIG.virtualSize * renderScale) / 2;
  const offsetY = (canvas.height - CONFIG.virtualSize * renderScale) / 2;
  ctx.translate(offsetX, offsetY);
  ctx.scale(renderScale, renderScale);

  for (let i = 0; i < total; i++) {
    const q = renderList[i];
    if (q.z > 2500) continue;
    const hue = (hueShift + (i / total) * 360) % 360;
    const sheenEffect = Math.min(CONFIG.colors.maxSheen, sheen); 
    const light = CONFIG.colors.baseLight + sheenEffect; 
    const alphaFill = q.isFront ? CONFIG.colors.alphaFrontFill : CONFIG.colors.alphaBackFill; 
    const alphaStroke = q.isFront ? CONFIG.colors.alphaFrontStroke : CONFIG.colors.alphaBackStroke;
    
    ctx.strokeStyle = `hsla(${hue}, ${CONFIG.colors.satStroke}%, ${light + 10}%, ${alphaStroke})`;
    ctx.lineWidth = 2 / renderScale; 
    ctx.fillStyle = `hsla(${hue}, ${CONFIG.colors.satFill}%, ${light}%, ${alphaFill})`;
    ctx.beginPath();
    ctx.moveTo(q.p[0].x, q.p[0].y);
    ctx.lineTo(q.p[1].x, q.p[1].y);
    ctx.lineTo(q.p[2].x, q.p[2].y);
    ctx.lineTo(q.p[3].x, q.p[3].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();
  requestAnimationFrame(draw);
}

window.addEventListener('deviceorientation', e => {
  if (e.gamma === null) return;
  targetHue = (e.gamma * 4 + 360) % 360; 
  const tilt = Math.abs(e.beta - 45); 
  targetSheen = tilt * 1.5; 
});
window.addEventListener('mousemove', e => {
    if(!isDragging) {
        targetHue = (e.clientX / window.innerWidth) * 360;
        targetSheen = (e.clientY / window.innerHeight) * 50;
    }
});

const startDrag = (x, y) => { isDragging = true; lastX = x; lastY = y; dragDistance = 0; document.body.style.cursor = "grabbing"; };
const moveDrag = (x, y) => { 
  if (!isDragging) return; 
  const dx = x - lastX;
  const dy = y - lastY;
  dragDistance += Math.abs(dx) + Math.abs(dy);
  targetRotY += dx * 0.005; 
  targetRotX += dy * 0.005; 
  lastX = x; 
  lastY = y; 
};
const endDrag = () => { isDragging = false; document.body.style.cursor = "grab"; };

canvas.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
window.addEventListener('mouseup', endDrag);
canvas.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
window.addEventListener('touchmove', e => { e.preventDefault(); moveDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
window.addEventListener('touchend', endDrag);

canvas.addEventListener('click', (e) => {
  if (dragDistance < 10) init();
});

init();
draw();
</script>
</body>
</html>
